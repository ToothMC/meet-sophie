<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sophie Voice</title>

<style>
*{box-sizing:border-box}

body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  color:white;
  text-align:center;
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#0b0f14;
  position:relative;
  overflow:hidden;
}

/* Topbar */
.topbar{
  position:fixed;
  top:0; left:0; right:0;
  z-index:3;
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:14px 16px;
}

.topbar a{
  color:rgba(255,255,255,.9);
  text-decoration:none;
  font-weight:600;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.18);
}

.topbar button{
  color:rgba(255,255,255,.9);
  font-weight:600;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.18);
  cursor:pointer;
}

.topbar button:disabled{
  opacity:.5;
  cursor:not-allowed;
}

/* Hintergrundbild */
.bg{
  position:fixed;
  inset:0;
  background:url("/sophie.jpg") center/cover no-repeat;
  opacity:0;
  transition:opacity .5s ease;
  z-index:0;
}

/* dunkles Overlay */
.overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  opacity:0;
  transition:opacity .5s ease;
  z-index:1;
}

/* Aktiv-Zustand */
.bg.active,
.overlay.active{ opacity:1; }

/* Vordergrund */
.wrap{
  position:relative;
  z-index:2;
  width:90%;
  max-width:420px;
  padding-top:40px; /* Platz für Topbar */
}

/* Buttons */
.btn{
  display:block;
  width:100%;
  margin:0 auto 15px;
  padding:18px 20px;
  font-size:20px;
  font-weight:700;
  border:none;
  border-radius:12px;
  cursor:pointer;
}

#start{ background:#ffffff; color:#000; }
#end{
  background:rgba(255,255,255,.15);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.btn:disabled{ opacity:.5; cursor:not-allowed; }

.status{ margin-bottom:10px; opacity:.88; }
.timer{ margin-bottom:20px; opacity:.75; font-size:14px; }
</style>
</head>

<body>

<div class="bg" id="bg"></div>
<div class="overlay" id="overlay"></div>

<div class="topbar">
  <a href="/">← Landing</a>
  <button id="logoutBtn" type="button">Logout</button>
</div>

<div class="wrap">
  <h2 id="headline">Sophie is here.</h2>
  <div class="status" id="status">Whenever you’re ready.</div>
  <div class="timer" id="timer">Zeit: --:--</div>

  <button id="start" class="btn">Enter the Room</button>
  <button id="end" class="btn" disabled>Leave the Room</button>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

// ✅ Supabase Config
const SUPABASE_URL = "https://ohzfojsbmzinpxhcynpt.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9oemZvanNibXppbnB4aGN5bnB0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0Mzc1MjcsImV4cCI6MjA4NzAxMzUyN30.7eGSeEvOCj9vMqFJj9C0SR8DiiYygbFUvpQ8rIVEc0I";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ✅ Frontend Login Guard: ohne Session -> /login/
const { data: { session } } = await supabase.auth.getSession();
if (!session?.user) {
  window.location.href = "/login/";
}

// --- Tracking helper (POST /api/track) ---
async function track(event_name, meta = {}) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) return;

    await fetch("/api/track", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ event_name, meta }),
      keepalive: true,
    });
  } catch (_) {}
}

// --- Usage reporting helper (POST /api/usage) ---
async function reportUsage(secondsUsed) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) return;

    await fetch("/api/usage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ seconds_used: secondsUsed }),
      keepalive: true,
    });
  } catch (_) {}
}

// --- Memory update helper (POST /api/memory-update) ---
async function sendMemoryUpdate(secondsUsed) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) return;

    const finalA = (partialAssistant || "").trim();
    if (finalA) {
      convoLog.push({ role: "assistant", text: finalA });
      partialAssistant = "";
    }

    const cleaned = (convoLog || []).filter(t => {
      const role = String(t?.role || "");
      const text = String(t?.text || "").trim();
      if (!text) return false;
      if (role === "user" && text.toLowerCase() === "bye.") return false;
      return true;
    });

    const payload = cleaned.slice(-80);

    await fetch("/api/memory-update", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ transcript: payload, seconds_used: secondsUsed }),
      keepalive: true,
    });

    convoLog = [];
  } catch (_) {}
}

// UI Elements
const startBtn = document.getElementById("start");
const endBtn   = document.getElementById("end");
const statusEl = document.getElementById("status");
const timerEl  = document.getElementById("timer");
const headline = document.getElementById("headline");
const bg = document.getElementById("bg");
const overlay = document.getElementById("overlay");
const logoutBtn = document.getElementById("logoutBtn");

// Voice vars
let pc = null;
let stream = null;
let audioEl = null;

// DataChannel + Transcript logging
let dc = null;
let convoLog = [];
let partialAssistant = "";

// buffer for user transcript deltas
const userTranscriptBuffer = new Map();
let lastAssistantFinal = "";

// Timer vars
let countdown = null;
let remainingSeconds = 0;     // ✅ NICHT mehr hardcoded
let isPremium = false;        // bleibt für tracking
let plan = null;              // optional

// Session meta
let talkStartedAt = null;

// dynamic reset interval
let dynamicResetInterval = null;

// ✅ Cliffhanger trigger flag (minimal change)
let cliffhangerTriggered = false;

function setStatus(txt){ statusEl.textContent = txt; }

function showBackground(on){
  if(on){
    bg.classList.add("active");
    overlay.classList.add("active");
  } else {
    bg.classList.remove("active");
    overlay.classList.remove("active");
  }
}

function formatMMSS(sec){
  const s = Math.max(0, Math.floor(Number(sec) || 0));
  const m = String(Math.floor(s/60)).padStart(2,"0");
  const r = String(s%60).padStart(2,"0");
  return `${m}:${r}`;
}

function renderTimer(){
  timerEl.textContent = `Zeit: ${formatMMSS(remainingSeconds)}`;
}
renderTimer();

function startCountdown(){
  // Countdown läuft immer, egal ob free/paid/topup – sobald remainingSeconds gesetzt ist.
  if (countdown) clearInterval(countdown);
  countdown = setInterval(() => {
    remainingSeconds -= 1;
    renderTimer();

    // ✅ 15s Cliffhanger trigger (minimal, no UI changes)
    if (!cliffhangerTriggered && remainingSeconds === 15 && dc && dc.readyState === "open") {
      cliffhangerTriggered = true;
      try {
        dc.send(JSON.stringify({
          type: "response.create",
          response: {
            modalities: ["audio", "text"],
            instructions: `
CLIFFHANGER MODE NOW.
Say the premium cliffhanger exactly in this structure:

"There’s something I’d like to tell you about that.
But this isn’t a conversation for in-between moments.

If we do this…
we do it properly."

Short pause.

"Just tell me if you want me to stay."

Rules:
- Do NOT mention time limits.
- Do NOT explain pricing.
- Keep it intimate, calm, and natural.
- Finish cleanly. No abrupt stop.
`
          }
        }));
      } catch (_) {}
    }

    if (remainingSeconds <= 0) {
      clearInterval(countdown);
      countdown = null;
      setStatus("Zeitlimit erreicht.");

      track("time_limit_reached", { plan: plan || null });

      stopVoice(true).finally(() => {
        window.location.href = "/pricing/";
      });
    }
  }, 1000);
}

function stopCountdown(){
  if (countdown) { clearInterval(countdown); countdown = null; }
}

function stopDynamicResets(){
  if (dynamicResetInterval) {
    clearInterval(dynamicResetInterval);
    dynamicResetInterval = null;
  }
}

function triggerDynamicReset(){
  if (dc && dc.readyState === "open") {
    try {
      dc.send(JSON.stringify({
        type: "response.create",
        response: {
          modalities: ["text"],
          instructions: `
Continue naturally.
Refresh your inner energy and spontaneity a little.
Do not change the topic.
Do not restart or re-greet.
Do not mention this instruction.
Avoid becoming explanatory or generic.
Stay present, warm, and human.
`
        }
      }));
    } catch (_) {}
  }
}

function startDynamicResets(){
  stopDynamicResets();
  dynamicResetInterval = setInterval(triggerDynamicReset, 120000);
}

async function safeJson(res) {
  try { return await res.json(); } catch { return null; }
}

// Robust DataChannel handling: server-created + client-created
function attachChannel(ch) {
  dc = ch;

  dc.addEventListener("open", () => {
    try {
      dc.send(JSON.stringify({
        type: "session.update",
        session: {
          input_audio_transcription: { model: "gpt-4o-mini-transcribe" },
          turn_detection: { type: "server_vad" }
        }
      }));
    } catch (_) {}
  });

  dc.addEventListener("message", (ev) => {
    try {
      const msg = JSON.parse(ev.data);

      if (msg?.type === "conversation.item.input_audio_transcription.delta") {
        const itemId = msg?.item_id;
        const delta = String(msg?.delta || "");
        if (itemId && delta) {
          const prev = userTranscriptBuffer.get(itemId) || "";
          userTranscriptBuffer.set(itemId, (prev + delta));
        }
        return;
      }

      if (msg?.type === "conversation.item.input_audio_transcription.completed") {
        const itemId = msg?.item_id;
        const t1 = String(msg?.transcript || "").trim();
        const tBuf = itemId ? String(userTranscriptBuffer.get(itemId) || "").trim() : "";
        const text = (t1 || tBuf).trim();

        if (itemId) userTranscriptBuffer.delete(itemId);
        if (text) convoLog.push({ role: "user", text });
        return;
      }

      if (msg?.type === "conversation.item.created" || msg?.type === "conversation.item.done") {
        const item = msg?.item;
        if (item?.role === "user" && Array.isArray(item?.content)) {
          const text = item.content.map(p => p?.transcript || p?.text || "").join(" ").trim();
          if (text) convoLog.push({ role: "user", text });
        }
      }

      if (msg?.type === "response.audio_transcript.delta") {
        const chunk = String(msg?.delta || "");
        if (chunk) partialAssistant += chunk;
        return;
      }

      if (msg?.type === "response.audio_transcript.done") {
        const full = String(msg?.transcript || msg?.text || "").trim();
        if (full) partialAssistant = full;
        return;
      }

      if (msg?.type === "response.output_text.delta") {
        const chunk = String(msg?.delta || "");
        if (chunk) partialAssistant += chunk;
        return;
      }

      if (msg?.type === "response.output_text.done") {
        const full = String(msg?.text || "").trim();
        if (full) partialAssistant = full;
        return;
      }

      if (msg?.type === "response.content_part.added" || msg?.type === "response.content_part.done") {
        const part = msg.part || {};
        const chunk = String(part.text || part.transcript || "");
        if (chunk) partialAssistant += chunk;
      }

      if (msg?.type === "response.done") {
        const final = String(partialAssistant || "").trim();
        if (final && final !== lastAssistantFinal) {
          convoLog.push({ role: "assistant", text: final });
          lastAssistantFinal = final;
        }
        partialAssistant = "";
      }
    } catch (_) {}
  });
}

function setupDataChannelLogging() {
  pc.ondatachannel = (e) => attachChannel(e.channel);
  try { attachChannel(pc.createDataChannel("oai-events")); } catch (_) {}
}

async function startVoice(){
  startBtn.disabled = true;
  logoutBtn.disabled = true;
  headline.textContent = "Sophie is joining…";
  setStatus("connecting..");
  showBackground(true);

  track("talk_start_clicked");

  convoLog = [];
  partialAssistant = "";
  lastAssistantFinal = "";
  userTranscriptBuffer.clear();

  // ✅ reset cliffhanger (minimal)
  cliffhangerTriggered = false;

  stopDynamicResets();

  try{
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.user) {
      window.location.href = "/login/";
      return;
    }

    const tokenRes = await fetch("/api/session", {
      headers: { Authorization: `Bearer ${session.access_token}` }
    });

    const data = await safeJson(tokenRes);

    if (tokenRes.status === 402) {
      track("time_limit_reached");
      window.location.href = "/pricing/";
      return;
    }

    if (!tokenRes.ok) {
      const msg = data?.error || `Kein Zugriff (HTTP ${tokenRes.status}).`;
      setStatus(msg);
      headline.textContent = "Sophie is waiting.";
      showBackground(false);
      startBtn.disabled = false;
      logoutBtn.disabled = false;
      track("talk_start_failed", { http_status: tokenRes.status, message: msg });
      return;
    }

    isPremium = !!data?.is_premium;
    plan = data?.plan || null;

    if (typeof data?.remaining_seconds === "number") {
      remainingSeconds = Math.max(0, data.remaining_seconds);
    } else {
      remainingSeconds = 0;
    }

    renderTimer();

    if (remainingSeconds <= 0) {
      track("time_limit_reached");
      window.location.href = "/pricing/";
      return;
    }

    pc = new RTCPeerConnection();
    setupDataChannelLogging();

    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => pc.addTrack(track, stream));

    audioEl = document.createElement("audio");
    audioEl.autoplay = true;
    audioEl.playsInline = true;
    pc.ontrack = e => audioEl.srcObject = e.streams[0];

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const baseUrl = "https://api.openai.com/v1/realtime";
    const model = "gpt-4o-realtime-preview";

    const sdpRes = await fetch(`${baseUrl}?model=${model}`, {
      method: "POST",
      body: offer.sdp,
      headers: {
        Authorization: `Bearer ${data.client_secret.value}`,
        "Content-Type": "application/sdp"
      },
    });

    if (!sdpRes.ok) {
      const t = await sdpRes.text().catch(() => "");
      throw new Error(`OpenAI SDP Fehler (HTTP ${sdpRes.status}): ${t.slice(0, 200)}`);
    }

    const answer = { type: "answer", sdp: await sdpRes.text() };
    await pc.setRemoteDescription(answer);

    endBtn.disabled = false;
    setStatus("Live.");
    headline.textContent = "Sophie is listening.";

    startDynamicResets();

    talkStartedAt = Date.now();
    track("talk_started", {
      is_premium: isPremium,
      plan: plan || null,
      remaining_seconds_at_start: remainingSeconds
    });

    startCountdown();

  } catch(err){
    console.error(err);
    setStatus("Fail to Start.");
    headline.textContent = "Sophie is waiting.";
    track("talk_start_exception", { message: String(err?.message || err) });
    stopVoice(false);
  }
}

async function stopVoice(triggeredByLimit = false){
  endBtn.disabled = true;
  stopDynamicResets();

  if (dc && dc.readyState === "open") {
    try {
      dc.send(JSON.stringify({
        type: "response.create",
        response: {
          instructions: `
Say one short, soft goodbye line.
Use the same language that was used in the last conversation.
Match the emotional tone of the last exchange.
Calm. Intimate. Low energy.
No explanation. No repetition.
Max 12 words.
`,
          modalities: ["audio", "text"]
        }
      }));

      await new Promise(r => setTimeout(r, 900));
    } catch (_) {}
  }

  const durationSeconds = talkStartedAt
    ? Math.round((Date.now() - talkStartedAt) / 1000)
    : 0;

  // ✅ Usage immer reporten (Backend entscheidet, aus welchem Bucket abgezogen wird)
  if (durationSeconds > 0) {
    await reportUsage(durationSeconds);
  }

  await sendMemoryUpdate(durationSeconds);

  track("talk_ended", {
    duration_seconds: durationSeconds || null,
    is_premium: isPremium,
    plan: plan || null,
    remaining_seconds_at_end: remainingSeconds,
    triggered_by_limit: !!triggeredByLimit
  });

  talkStartedAt = null;

  stopCountdown();

  if (dc) {
    try { dc.close(); } catch(e){}
    dc = null;
  }

  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }

  if(pc){
    try{ pc.close(); } catch(e){}
    pc = null;
  }

  if(audioEl){
    try{ audioEl.srcObject = null; } catch(e){}
    audioEl = null;
  }

  showBackground(false);

  startBtn.disabled = false;
  logoutBtn.disabled = false;
  headline.textContent = "Sophie is waiting.";
  setStatus("Ended.");
}

logoutBtn.onclick = async () => {
  try {
    track("logout_clicked");
    if (pc || stream || talkStartedAt) {
      await stopVoice(false);
    }
  } catch(e) {}

  try { await supabase.auth.signOut(); } catch(e) {}
  window.location.href = "/";
};

startBtn.addEventListener("click", startVoice);
endBtn.addEventListener("click", () => stopVoice(false));
</script>

</body>
</html>
