<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sophie Voice</title>

<style>
*{box-sizing:border-box}

body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  color:white;
  text-align:center;
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#0b0f14;
  position:relative;
  overflow:hidden;
}

/* Topbar */
.topbar{
  position:fixed;
  top:0; left:0; right:0;
  z-index:3;
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:14px 16px;
}

.topbar a{
  color:rgba(255,255,255,.9);
  text-decoration:none;
  font-weight:600;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.18);
}

.topbar button{
  color:rgba(255,255,255,.9);
  font-weight:600;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.18);
  cursor:pointer;
}

.topbar button:disabled{
  opacity:.5;
  cursor:not-allowed;
}

/* Hintergrundbild */
.bg{
  position:fixed;
  inset:0;
  background:url("/sophie.jpg") center/cover no-repeat;
  opacity:0;
  transition:opacity .5s ease;
  z-index:0;
}

/* dunkles Overlay */
.overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  opacity:0;
  transition:opacity .5s ease;
  z-index:1;
}

/* Aktiv-Zustand */
.bg.active,
.overlay.active{ opacity:1; }

/* Vordergrund */
.wrap{
  position:relative;
  z-index:2;
  width:90%;
  max-width:420px;
  padding-top:40px; /* Platz f√ºr Topbar */
}

/* Buttons */
.btn{
  display:block;
  width:100%;
  margin:0 auto 15px;
  padding:18px 20px;
  font-size:20px;
  font-weight:700;
  border:none;
  border-radius:12px;
  cursor:pointer;
}

#start{ background:#ffffff; color:#000; }
#end{
  background:rgba(255,255,255,.15);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.btn:disabled{ opacity:.5; cursor:not-allowed; }

.status{ margin-bottom:10px; opacity:.88; }
.timer{ margin-bottom:20px; opacity:.75; font-size:14px; }
</style>
</head>

<body>

<div class="bg" id="bg"></div>
<div class="overlay" id="overlay"></div>

<div class="topbar">
  <a href="/">‚Üê Landing</a>
  <button id="logoutBtn" type="button">Logout</button>
</div>

<div class="wrap">
  <h2 id="headline">Sophie is waiting.</h2>
  <div class="status" id="status">Ready.</div>
  <div class="timer" id="timer">Free-Zeit: --:--</div>

  <button id="start" class="btn">Start talking</button>
  <button id="end" class="btn" disabled>End call</button>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

// ‚úÖ Supabase Config
const SUPABASE_URL = "https://ohzfojsbmzinpxhcynpt.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9oemZvanNibXppbnB4aGN5bnB0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0Mzc1MjcsImV4cCI6MjA4NzAxMzUyN30.7eGSeEvOCj9vMqFJj9C0SR8DiiYygbFUvpQ8rIVEc0I";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ‚úÖ Frontend Login Guard: ohne Session -> /login/
const { data: { session } } = await supabase.auth.getSession();
if (!session?.user) {
  window.location.href = "/login/";
}

// --- Tracking helper (POST /api/track) ---
async function track(event_name, meta = {}) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) return;

    await fetch("/api/track", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ event_name, meta }),
      keepalive: true,
    });
  } catch (_) {}
}

// --- Usage reporting helper (POST /api/usage) ---
// WICHTIG: keepalive + await in stop/logout, sonst geht der Request gern verloren
async function reportUsage(secondsUsed) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.access_token) return;

    await fetch("/api/usage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ seconds_used: secondsUsed }),
      keepalive: true,
    });
  } catch (_) {}
}

// UI Elements
const startBtn = document.getElementById("start");
const endBtn   = document.getElementById("end");
const statusEl = document.getElementById("status");
const timerEl  = document.getElementById("timer");
const headline = document.getElementById("headline");
const bg = document.getElementById("bg");
const overlay = document.getElementById("overlay");
const logoutBtn = document.getElementById("logoutBtn");

// Voice vars
let pc = null;
let stream = null;
let audioEl = null;

// Timer vars
let countdown = null;
let remainingSeconds = 15 * 60;
let isPremium = false;

// Session meta for tracking/usage
let talkStartedAt = null;

function setStatus(txt){ statusEl.textContent = txt; }

function showBackground(on){
  if(on){
    bg.classList.add("active");
    overlay.classList.add("active");
  } else {
    bg.classList.remove("active");
    overlay.classList.remove("active");
  }
}

function renderTimer(){
  if (isPremium) {
    timerEl.textContent = "Premium: unlimited";
    return;
  }
  const m = String(Math.floor(remainingSeconds/60)).padStart(2,"0");
  const s = String(remainingSeconds%60).padStart(2,"0");
  timerEl.textContent = `Free-Time: ${m}:${s}`;
}
renderTimer();

function startCountdown(){
  if (isPremium) return;

  if (countdown) clearInterval(countdown);
  countdown = setInterval(() => {
    remainingSeconds -= 1;
    renderTimer();

    if (remainingSeconds <= 0) {
      clearInterval(countdown);
      countdown = null;
      setStatus("Free-Time limit reached.");

      track("free_limit_reached");

      // Nutzungszeit beim Limit-Ende melden
      if (talkStartedAt && !isPremium) {
        const durationSeconds = Math.round((Date.now() - talkStartedAt) / 1000);
        if (durationSeconds > 0) reportUsage(durationSeconds);
      }

      // Call beenden + Paywall
      stopVoice().finally(() => {
        window.location.href = "/pricing/";
      });
    }
  }, 1000);
}

function stopCountdown(){
  if (countdown) { clearInterval(countdown); countdown = null; }
}

async function safeJson(res) {
  try { return await res.json(); } catch { return null; }
}

async function startVoice(){
  startBtn.disabled = true;
  logoutBtn.disabled = true;
  headline.textContent = "Sophie is connecting‚Ä¶";
  setStatus("Verbinde‚Ä¶");
  showBackground(true);

  track("talk_start_clicked");

  try{
    // ‚úÖ immer frische Session holen (Token kann rotieren)
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.user) {
      window.location.href = "/login/";
      return;
    }

    // ‚úÖ Token vom Server holen, mit Authorization Header
    const tokenRes = await fetch("/api/session", {
      headers: { Authorization: `Bearer ${session.access_token}` }
    });

    const data = await safeJson(tokenRes);

    // ‚úÖ Paywall: Free Limit erreicht -> Pricing
    if (tokenRes.status === 402) {
      track("free_limit_reached");
      window.location.href = "/pricing/";
      return;
    }

    if (!tokenRes.ok) {
      const msg = data?.error || `Kein Zugriff (HTTP ${tokenRes.status}).`;
      setStatus(msg);
      headline.textContent = "Sophie is waiting.";
      showBackground(false);
      startBtn.disabled = false;
      logoutBtn.disabled = false;

      track("talk_start_failed", { http_status: tokenRes.status, message: msg });
      return;
    }

    // ‚úÖ Premium Flag vom Server
    isPremium = !!data?.is_premium;

    // ‚úÖ Remaining Sekunden vom Server nutzen (nur relevant bei Free)
    if (!isPremium && typeof data?.remaining_seconds === "number") {
      remainingSeconds = Math.max(0, data.remaining_seconds);
    }

    renderTimer();

    // Wenn Free und schon 0 -> direkt Pricing
    if (!isPremium && remainingSeconds <= 0) {
      track("free_limit_reached");
      window.location.href = "/pricing/";
      return;
    }

    pc = new RTCPeerConnection();
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => pc.addTrack(track, stream));

    audioEl = document.createElement("audio");
    audioEl.autoplay = true;
    audioEl.playsInline = true;
    pc.ontrack = e => audioEl.srcObject = e.streams[0];

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const baseUrl = "https://api.openai.com/v1/realtime";
    const model = "gpt-4o-realtime-preview";

    const sdpRes = await fetch(`${baseUrl}?model=${model}`, {
      method: "POST",
      body: offer.sdp,
      headers: {
        Authorization: `Bearer ${data.client_secret.value}`,
        "Content-Type": "application/sdp"
      },
    });

    if (!sdpRes.ok) {
      const t = await sdpRes.text().catch(() => "");
      throw new Error(`OpenAI SDP Fehler (HTTP ${sdpRes.status}): ${t.slice(0, 200)}`);
    }

    const answer = { type: "answer", sdp: await sdpRes.text() };
    await pc.setRemoteDescription(answer);

    endBtn.disabled = false;
    setStatus("Live.");
    headline.textContent = "Sophie is listening.";

    // tracking: started
    talkStartedAt = Date.now();
    track("talk_started", {
      is_premium: isPremium,
      remaining_seconds_at_start: isPremium ? null : remainingSeconds
    });

    startCountdown();

  } catch(err){
    console.error(err);
    setStatus("Fail to Start.");
    headline.textContent = "Sophie is waiting.";
    track("talk_start_exception", { message: String(err?.message || err) });
    stopVoice();
  }
}

// üî• stopVoice muss async sein, damit usage sicher weggeschrieben wird
async function stopVoice(){
  endBtn.disabled = true;

  const durationSeconds = talkStartedAt ? Math.round((Date.now() - talkStartedAt) / 1000) : 0;

  // ‚úÖ Usage an Server melden (nur Free User) ‚Äî AWAIT, sonst geht's gerne verloren
  if (durationSeconds > 0 && !isPremium) {
    await reportUsage(durationSeconds);
  }

  // tracking: ended
  track("talk_ended", {
    duration_seconds: durationSeconds || null,
    is_premium: isPremium,
    remaining_seconds_at_end: isPremium ? null : remainingSeconds
  });

  talkStartedAt = null;

  stopCountdown();

  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }

  if(pc){
    try{ pc.close(); } catch(e){}
    pc = null;
  }

  if(audioEl){
    try{ audioEl.srcObject = null; } catch(e){}
    audioEl = null;
  }

  showBackground(false);

  startBtn.disabled = false;
  logoutBtn.disabled = false;
  headline.textContent = "Sophie is waiting.";
  setStatus("Ended.");
}

// Logout: erst sauber stoppen (usage schreiben), dann signOut
logoutBtn.onclick = async () => {
  try {
    track("logout_clicked");

    if (pc || stream || talkStartedAt) {
      await stopVoice();
    }
  } catch(e) {}

  try { await supabase.auth.signOut(); } catch(e) {}
  window.location.href = "/";
};

startBtn.addEventListener("click", startVoice);
endBtn.addEventListener("click", () => stopVoice());
</script>

</body>
</html>
